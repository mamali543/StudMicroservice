
                             *******************************Spring Introduction*******************************

Spring is a java framework built to create an enterprise real application
*Spring framework makes it easy to build application but there is a lot of configurations that we have to do
and with that spring developors taught of creating something easy so all the developors can really concentrate on that actual work
(only the convention not the configuration part) and that was Spring Boot it's just the extension of Spring framework and it use it
internally and it uses keys benifits for use for java developers(it offers the auto configuration)

*Apache tomCat is a free and open-source implementation of Jakarta servlet, and websocket tecknologies
and it provides a pure "Java Http  web server envirenment in which java code also can run , thus is a java web applicatyon server 

*there is a server in the cloud and within it there is tomcat is an embeded servlet container and inside we also have the springboot application
so each spring boot app includes an embeded tomcat webserver

*@RestController and @GetMapping these are annotations which are part of the SPRING WEB MVC.
-The Spring Web MVC is an easy way of implementing MVC architechture in our web App.
-Spring MVC  abstracts away a lot of messy details u would have to understand and manage yourself if u want to write a servlet manually.
-A servlet is a process wich handles http requests.
-So Spring Web MVC allows us to create restful services very easy, and within it there's a lot of annotations that helps us to do so.

*The @Autowired annotation is used in Spring Boot to automatically wire (i.e. connect) dependencies
between different components in your application

*The @Override annotation is used to indicate that a method in a subclass or implementation class is intended to override a method declared
in a parent class or interface

*@Id is indicating that this id is the unique identifier for this user class
and @GeneratedValue indicates that the id is autogenerated and autoincrement whenever I add a user

*the @Builder annotation is used to generate a builder class for the User class. The builder class will have methods to set each of the attributes of the User class.
With the builder class generated by Lombok, you can create instances of User class with a fluent API like this:
User user = User.builder()
    .firstName("John")
    .lastName("Doe")
    .age(30)
    .email("john.doe@example.com")
    .build();

*the @Configuration annotation is used to indicate that a class is a configuration class that defines one or more Spring beans. The beans defined in a @Configuration
class are managed by the Spring container and can be injected into other Spring components, At the startup spring will pick up this class and try to implement and
inject all the beans declared withing this configuration class, and one other thing the beans are all declared public

*records are classes that allows us to achive immutabilities

*Jakson is Json for Java (JavaScript Object Notation)

*the POSTGRESSQL JDBC DRIVER allows java programs to connect to a POSTGRESSQL database using standard database independent java code.
-and while we are using spring data JPA we are depending on the POSTGRESSQL JBDC DRIVER

*spring data JPA it allows us to map java classes to database tables to directly interact with our databse without having to write sql code.

*Spring Data JPA is an amazing framework that abstracts all the complexity needed from u to interact with the database

*hibernate is an implementation of JPA interface

*Postman is a client that allows us to test our APIs


                             *******************************Unit tests: Junit and Mockito*******************************

*in order to write tests in the java world u will most likely be using Junit5

*JUnit is a popular testing framework for Java-based applications,

*Having no tests gives you no assurance of the quality of your software, so if u introduce a new feature then
u don't know whether if u have broken anything

*we don't want to run the tests against our local database because the data produced by this unit tests
we don't want to keep them in our database

*H2 database engine is an open source sql database and u can use it as an in-memory

*Assertions library is a collection of utility methods that support asserting conditions in tests

*AssertJ is an assertion,library that provides rich set of assertions that improves your test code readability

*BDD stands for Behavior Driven Development,It uses a specific format for writing test cases called "Gherkin,"
it follows the Given-When-Then format, which is a way of structuring test cases to describe the behavior
of the system in a clear and concise manner

*if u want to unit test ur repository u need to add the @DataJpaTest annotation to ur class

*The @Mock annotation is part of the Mockito library, which is a popular testing framework used for mocking
dependencies in unit tests.

*By initializing mock objects, we can simulate the behavior of external dependencies, such as a database,
a web service, or a third-party library, and test our code in isolation from these dependencies. This makes
our tests faster, more predictable, and easier to debug, and it helps us catch bugs early in the development process.

*The benefit that we get with that is that our unit test is now fast, so we don't have to bring the database
create the table, insert a new student drop the database and all the other stuff

* using @Mock allows you to create mock objects that simulate the behavior of external dependencies,
 so you can test your code in isolation and ensure that it behaves correctly in all scenarios.

*To use a mock object in a test, we need to first initialize it. Initialization means creating
an instance of the mock object and setting it up to behave in a specific way for the test.

*@ExtendWith(MockitoExtension.class) Annotation it's responsible for initialising all the mock abjects in the class and do a lot of stuff
that we can do manually like:
    private AutoCloseable autoCloseable;

    autoCloseable = MockitoAnnotations.openMocks(this);
    @AfterEach
        void tearDown() throws Exception {
            this allows us to close the resource after the test
            autoCloseable.close();
        }
    and more.

                             *******************************Spring Security*******************************

*******How the Jwt validation mechanism works:

*The whole story starts when a client sends an HTTP request to our Backend system, and the first thing that gets executed is the filter(JWTAuthFilter)
and it has the role to validate and check everything regarding the JWT Token, first things that happens is the INTERNAL CHECK to check if we have the
JWT Token, if the token is missing a 403 response will be sent to the client for missing JWT reason, after checking the JWT token the validation process
starts, so the filter will first make a call using the UserDetailsService to try to fetch the user information from the database and this will base on
the user email or token subject that we will set as a claim that we will extract from the JwtAuthFilter, after that then once the user is fetched
we have the response from the database it can be either way user exist or doesn't exist we will send a 403 response for our client, in case everything
is fine, and we got our user from the database we will start then the validation process, we will call the JWT service which takes in parameter the JWT token
and the user and after the execution of this validation process we can have two case scenarios:the token isn't valid(expired or isn't for the specific user)
we also send a 403 response for our client reason: Invalid JWT token, otherwise we'll update the security context holder and set the connected user we'll tell
spring that this user is now authenticated and we'll update the authentication manager so every time we check if this user is authenticated for this request
the answer will be yes, once the SECURITY CONTEXT HOLDER will be updated it will automatically dispatch the request to the dispatcher servlet and then be sent
directly to the controller and doing all the execution that we want to do (calling services, going to tha database) and then send back a response

*We want the filter to get fired every time we get a new request and do all the job that we wanted to do

*When we make a request we pass the JWT authentication token within the header called authorisation, after checking the Jwt token we call the user detail services
to check if we have user already in the database or not, to do that we need to call the JwtService to extract the username

*JWT token stands for a Json Web Token and it's a compact url of representing claims to be transferred between two parties the claims in JWT are encoded as a
JSON object that's digitally signed using a json web signature, so the JWT consists of three parts: the header, payload and signature, the header consists of two
parts: the type of the token which is JWT and the sign-in algorithm being used, then the second part the payload which contains the claims that are statements
about an entity typically the user and additional data, and there's three types of claims: registered public and private, finally the third part is the signature
which is used to verify the sender of the jwt is who it is claims to be and to ensure that the message wasn't changed along the way.

*the signing key is used in conjunction with the signing algorithm specified in the jwt header to create the signature.

*the specific signing algorithm and the key size will depend on the security requirement of your application.

*When we talk about Authorisation or Authentication Mainly we talk about users

*When spring boot starts it will use an object called userDetails interface that contains a bunch of methods, and whenever u're working with spring security u have
to ensure to provide this userDetails object

*@Bean:to make a class to be a Bean we add the @Service or @Component annotation, and there's others, and a Bean is a java object that is managed by the Spring
container, Beans can be injected into other beans or classes using Spring's dependency injection mechanism.

*Managed beans are created and initialized by the Spring container,When the Spring container starts up, it will create an instance of the bean and make it available
for use by other components. You can inject this bean into other components using dependency injection

*what are the credentials that are needed in the parameters of UsernamePasswordAuthenticationToken()?::
      - When you create an instance of UsernamePasswordAuthenticationToken, you need to provide the following credentials as parameters:
       principal - This is typically the username or email address of the user trying to authenticate.
       credentials - This is the password or other secret credential that the user is providing to authenticate.

*the third parameter that UsernamePasswordAuthenticationToken() takes is: The userDetails.getAuthorities() method it is used to retrieve the user's authorities
 (i.e. roles) from the UserDetails object

*Once the UsernamePasswordAuthenticationToken object is created, it can be used to authenticate the user.This typically involves passing the
UsernamePasswordAuthenticationToken object to the AuthenticationManager, which will use the UserDetailsService to load the user's details and validate the provided
credentials. If the user's details and credentials are valid, the AuthenticationManager will return a fully authenticated Authentication object (which can be used
to perform authorization checks). If the authentication fails, an AuthenticationException will be thrown.

*The authentication manager is the one responsible for manage the authentication.

*After implementing the whole process there's still some extra steps:
    -tell spring which configuration that we want to use in order to make all the things works and to use the filter by binding it.

*At the Application startup spring security will look for beans of type securityFilerChain ,and it is responsible for configuring all the http security for our app

*the AuthenticationProvider is the data access object which is responsible for fetch the user details  and encode password and so forth, and within this
AuthProvider we need to specify two properties: the userDetailService to use in order to fetch information about the user, then provide a password encoder
because when we want to authenticate a user we need it to decode the password

*when finishing with the configuration needed for the spring security we need to provide the endpoints where the user can create an account or also can authenticate.

                             *******************************Things U have To get your Head Around*******************************

*@Query is an annotation that indicates that the method is a custom query and specifies the query string to be executed.
*SELECT COUNT(s) > 0 is the select clause of the query. It selects the count of the students with a specific email and checks if it's greater than 0.
*FROM Student s specifies the entity class to be queried (i.e., the Student class) and assigns it the alias s.
*WHERE s.email = :email is the where clause of the query. It filters the students by the email specified as a parameter to the query.


*existsByEmail() it follows the Spring Data JPA method naming convention and
will automatically generate the SQL query based on its name

  @Query("SELECT COUNT(s) > 0 FROM Student s WHERE s.email = :email")
*The line of code you provided is a JPA (Java Persistence API) query that is used
to check whether a student with a specific email exists in the database. The query is written using
JPQL (Java Persistence Query Language), which is a query language similar to SQL but is used to perform operations
on objects rather than on tables.

* In Spring Boot, the Specification interface is used to define a set of criteria that can be used to query a database for certain records.
It allows you to create complex queries with multiple conditions and combine them using logical operators like AND and OR.
The in method you're using is a static method of the Specifications class, which is a utility class that provides helper methods for creating
Specification objects. This particular method is used to create a Specification that checks whether a certain field in a Student entity
is contained in a given list of values


*The in method is a utility method from the Spring Data JPA library that creates a JPA Specification to filter the results of a query based on a list of values.
 A JPA Specification is a predicate that describes the criteria for filtering the results of a query. It is created using the Criteria API, which is a programmatic
 way of constructing queries in JPA. In your case, the in method takes two arguments:
 field: The name of the field in the Student entity that you want to filter on.
 values: A list of values that you want to filter on.
 The method returns a Specification object that you can use to filter the results of a query.
 The Specification object is a predicate that describes the criteria for filtering the results of a query. It is created using the Criteria API,
 which is a programmatic way of constructing queries in JPA.
 The Specification object returned by the in method is a predicate that filters the results based on whether the value of the specified field
 is in the list of values provided.Here's how the in method works:
 It creates a new lambda expression that implements the Specification interface.
 The lambda expression takes three arguments:
 root: The root entity of the query.
 query: The query being constructed.
 cb: A CriteriaBuilder object used to construct criteria expressions.
 The lambda expression calls the in method on the root entity to create an IN expression that filters the results based on whether the value of the specified field
 is in the list of values provided.
 The lambda expression returns the IN expression as the result of the Specification.

*in the repository we usually use the query method provided by spring jpa,for example:findBy and then provide the attribute or the field name that u have in ur class

                             *******************************Things I have to understand and ask about*******************************



*i want to know when usually the jwt token gets created


                             *******************************Keycloak*******************************

*Keycloak est un serveur qui est base sur l'aspect jpa et qu'on peut l'interfacer sur n'importe quel base de donnees par defaut il utilise une base
de donnes e type H2

*Keycloak est un outil qui permet de securiser les application, il se base sur des protocoles de securite tels que: OpenID Connect, OAuth2, SAML 2.

*comment keycloak securise les applications?:
    -il dispose des adaptateur qui permetent de faciliser la securite des applications en fonction de la tecknologie qu'on utilise


*le mechanisme d'echange de redirection, la demande de token et la recuperation du jwt est fait par keycloak adapter



*Le process comment ca marche :
    -au depart on va demander l'applictaion localhost:4200 l'application va s'aficher cote browser comme la page d'acceuil (page template) dans il
     ya des resources qu'on peut consulter sans authentification et d'autres routes proteges par keycloakAdapter comme /add on va etre rediriges vers
     keycloak qui vas nous fournir le formulaire pour saisir username et le password on fait le post des donnes et il vas nous authentifie si c'est le
     cas il vas nous rediriger vers l'application (Angular) avec un code d'authorisation et Angular a partir de ce code d'authorisation il envoie une
     requete vers keycloak pour recuperer le token (JWT)

*la premiere des choses a faire quand creer un compte keycloak c'est: creer un realme(un territoire a securiser, royaume a securiser)
  -u realme concerne un ensemble d'application a securiser
  -dans un realme on va creer les applications a securiser (les applications clients): Clients, clientId, HOME url: url de l'app a securiser, Valid
    Redirect URI's: les Uri de redirection qui sont autorisees,Valid Post Logout Redirect URI: ou se rediriger pendant logout,  Web Origins: * sa veut
    dire j'autorise n'import quel domaine d'envoyer des requetes vers keycloak.
  -ajouter des users avec des mot de passe credentials
  -assigner des roles a ces users.

*pour securiser un service avec keycloak nous avous besoin:
    1-d'ajouter 2 depandence: keycloakAdapter et springSecurity

   2-apres en creent notre package securite: et on va ajouter 2 classe de configuration (keycloakSecurityConfig) qui devrait heriter de
    KeycloakWebSecurityConfigureAdapter dans cette classe on va redifinir 3 methodes:SessionAuthenticationStrategy sessionAuthenticationStrategy(), configure(Authentiction
    ManagerBuilder), et la 3eme configure(HttpSecurity) qui recoit Http security et (keycloakAdapterConfig) pour configurer l'adaptateur keycloak qui a besoin d'un certain
    nombre de parametre de configuration:
        -ajouter les parametres de configuration toujour avec spring security mais cette fois si on va utiliser une configuration keycloak adapter qui elle
         meme herite de spring security, le premier dans le fichier applications.properties il va faloir d'indiquer a l'application un certain nombre de propriete:
                            keycloak.realm=on indique notre realm comment il s'appele.
                            keycloak.resource=la resource qu'ont veut securiser(client_id)
                            keycloak.bearer-only=pour acceder a cette api restfull il faut envoyer le token jwt
                            keycloak.auth-server-url=il faut indiquer ou se trouve keycloak car au demarage keycloak adapter envoie une requete vers keycloak
                                                       vers un fichier et il recupere les informations sur public key etc
                            keycloak.ssl-required=indiquer si vous voulew utilisez ssl
  *en realite pour keycloak adapter les informations de proprietes de configuration devront etre dans un keycloak.json car lorsque l'application demare il va le chercher.
    3-indiquer qu'on vas utiliser le fichier application.properties qui appartient a springBoot, donc il va faloir creer un objet de configuration pour indiquer qu'on vas
    utiliser une configuration basees sur springBoot.

*Pour securiser l'app angular nous avons besoins de:
    1-installer les 2 depandances : keycloak-js keycloak-angular qui vont nous installer un module keycloakAngular
    2-acceder a app.modules dont on vas importer le module: keycloakAngularModule et on vas creer une fonction factory qui vas demarer keycloak au demarage
*si on veut proteger les routes on choisissons onLoad:"check-sso" nous avons besoin d'un guard


